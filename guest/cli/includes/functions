#!/usr/bin/env bash

#
# Reads the config file /vagrant/.wplib.box.json and returns a value
#
# $1 - String
# $2 - String Optional if "require" then error if not there.
#
# Usage: git_url=$(read_config ".path.test.git_url")
#   Result: $git_url ==> "ssh://..."
#
#
function read_config() {
    require="$2"
    property=$(cat "${WPLIB_BOX_CONFIG_FILE}" | jq --raw-output "$1")
    if [ "null" == "${property}" ]; then
        if [ "require" == "${require}" ]; then
            echo -e "\tERROR:"
            echo -e "\tThe config file ${WPLIB_BOX_CONFIG_FILE} does"
            echo -e "\tnot have a value for ${property}."
            return 1
        fi
    else
        echo "${property}";
    fi
}

#
# Outputs the file extension given a file name
#
# $1 - String
#
# Usage: string=$(to_lowercase "FOO.BAR")
#   Result: $string ==> "foo.bar"
#
#
function to_lowercase() {
    echo "${1,,}"
}

#
# Outputs the file extension given a file name
#
# $1 - Filename
#
# Usage: extension=$(file_extension "foo/bar.baz")
#   Result: $extension ==> "baz"
#
#
function file_extension() {
    echo "${1##*.}"
}

#
# Outputs the base filename given a full filename
# Base filename means no path and no extension
#
# $1 - Filename
#
# Usage: basename=$(file_basename "foo/bar.baz")
#   Result: $basename ==> "bar"
#
function file_basename() {
    filename=$(basename "$1")
    echo "${filename%.*}"
}

#
# Returns a filename that does not exist given an existing filename.
#
# $1 - The backup file, e.g.  /vagrant/sql/backup.sql
#
# Outputs: The new file name in the form of {previous}{n}.{ext} where:
#
#       {previous} - Root filename for backup, e.g. /vagrant/sql/backup
#       {n}        - Ordinal position for prior backups, e.g. 1, 2, 3, etc
#       {ext}      - The file extension, e.g. sql
#
# Usage:  newbakfile=$(next_backup_file "${file_to_backup}")
#
function next_backup_file() {
    bakfile="$1"

    #
    # Get the file extension if there is one
    # See: http://stackoverflow.com/a/965072/102699
    #
    ext=$(file_extension "${bakfile}")
    if [[ "" == "${ext}" || "${ext}" == "${bakfile}" ]]; then
        ext=""
    fi


    #
    # Get the filepath sans extension
    # See: http://stackoverflow.com/a/965072/102699
    #
    bakfile="${bakfile%.*}"

    #
    # Now check to see if the default prior backup exists
    # Continue checking until we find a workable filename
    #
    test="${bakfile}.${ext}"
    until [ ! -e "${test}" ]; do
        counter=$((counter))
        let counter++
        test="${bakfile}${counter}.${ext}"
    done
    echo "${test}"
}

function is_dry_run() {
    if [[ "$1" == *"--dry-run"* ]]; then
        echo "true"
        return
    fi
    echo "false"
}

function is_quiet() {
    if [[ "$1" == *"--quiet"* ]]; then
        echo "true"
        return
    fi
    echo "false"
}

function is_wp_installed() {
    if [ "" == "${WPLIB_BOX_CONTENT_DIR}" ]; then
        echo "true"
        return
    fi
    echo "false"
}

#
# Generate output if -q|--quiet not in a string passed as $1.
#
# $1 - Always "$*", e.g. string containing parameters passed to the calling script
# $2 - String to echo if not quiet. Prefix string w/"=", "^", "&" or "=" to effect before and after echos.
#
function echo_if_not_quiet() {
    if [ "true" != $(is_quiet "$1") ]; then
        regex="s/\\\n/\n/g"
        control=${2:0:1}
        message=${2:1}
        case "${control}" in
            "^")
                echo -e "${message}" | sed "${regex}"
                echo
                ;;
            "*")
                echo
                echo -e "${message}" | sed "${regex}"
                echo
                ;;
            "=")
                echo -e "${message}" | sed "${regex}"
                ;;
            "&")
                echo
                echo -e "${message}" | sed "${regex}"
                ;;
            *)
                echo
                echo "CODING ERROR:"
                echo "Your message for echo_if_not_quiet() does not begin with one of: ^, *, = or &."
                echo
                ;;
        esac
    fi
}

function exit_if_wp_not_installed() {
    if [ "true" == $(is_wp_installed) ]; then
        echo "WordPress in not installed. Cannot $1."
        echo
        how_to_install_wp
        exit
    fi
}

#
# Check the "--force" option. If not set, output error message
#
# $1 - Always "$*", e.g. string containing parameters passed to the calling script
# $2 - Error message or optionally output
#

function exit_if_no_force_option() {
    if [[ "$1" != *"--force"* ]]; then
        echo "ERROR: $2. Cannot continue."
        echo
        echo -e "\tUse --force to force continue."
        echo
        exit
    fi
}

function find_composer_vendor_dir() {
    if [ -d "${WPLIB_BOX_WEB_ROOT_DIR}/vendor" ]; then
        echo "${WPLIB_BOX_WEB_ROOT_DIR}/vendor"
        return
    fi

    if [ -d "${WPLIB_BOX_DIR}/vendor" ]; then
        echo "${WPLIB_BOX_DIR}/vendor"
        return
    fi
}

function find_wp_content_dir() {
    if [ -d "${WPLIB_BOX_WEB_ROOT_DIR}/content" ]; then
        echo "${WPLIB_BOX_WEB_ROOT_DIR}/content"
        return
    fi

    if [ -d "${WPLIB_BOX_WEB_ROOT_DIR}/wp-content" ]; then
        echo "${WPLIB_BOX_WEB_ROOT_DIR}/wp-content"
        return
    fi
}

function find_wp_plugins_dir() {
    content_dir=$(find_wp_content_dir)
    echo "${content_dir}/plugins"
}

function find_wp_mu_plugins_dir() {
    content_dir=$(find_wp_content_dir)
    echo "${content_dir}/mu-plugins"
}

function how_to_install_wp() {
    echo "Download and install WordPress from the web,"
    echo
    echo -e "\tOR"
    echo
    echo "To install from a newly cloned WPLib Box repo use Composer FROM your HOST computer:"
    echo
    echo -e "\tcomposer install"
    echo
    echo If you are unfamiliar with Composer you can find installations instructions at one of:
    echo
    echo -e "\thttps://getcomposer.org/doc/00-intro.md#installation-linux-unix-osx"
    echo
    echo -e "\thttps://getcomposer.org/doc/00-intro.md#installation-windows"
    echo
    echo On Mac or Linux be sure to remember to move composer.phar to /usr/local/bin:
    echo
    echo -e "\tmv composer.phar /usr/local/bin/composer"
    echo
}

function delete_exclude_items() {
    root_dir="$1"
	index=0
	while :; do
	    item_to_exclude=$(read_config ".deployment.exclude[${index}]")
	    if [ "" == "${item_to_exclude}" ]; then
	        break
        fi
	    item_to_exclude="${root_dir}/${item_to_exclude}"
	    if [[ ! -f "${item_to_exclude}" &&  ! -d "${item_to_exclude}" ]];then
	        echo "NOTICE: ${item_to_exclude} is in exclude list in ${WPLIB_BOX_CONFIG_FILE} but does not exist on disk."
	    else
	        basename=$(basename "${item_to_exclude}")
	        echo_if_not_quiet "$*", "=Deleting ${basename}..."
	        rm -rf "${item_to_exclude}"
	    fi
	    index=$(( $index+1 ))
	done

}

#
# Echos the substring after a character
#
# $1 - String
# $2 - Character
#
# Usage: vendor_dir=$(substring_after "www/vendor" "/")
#   Result: $vendor_dir ==> "vendor"
#
#
function substring_after() {
    string="$1"
    character="$2"
    echo "${string#*${character}}"
}

#
# Runs Git commands, quietly, unless they fail
#
# See http://stackoverflow.com/a/8944284/102699
#
function quiet_git() {
    stdout=$(tempfile)
    stderr=$(tempfile)

    if ! git "$@" </dev/null >$stdout 2>$stderr; then
        cat $stderr >&2
        rm -f $stdout $stderr
        return 1
    fi

    rm -f $stdout $stderr
}

