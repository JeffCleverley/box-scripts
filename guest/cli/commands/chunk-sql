#!/usr/bin/env bash
#
# Converts a SQL file into a collection of `.sql.chunk` files
# in a directory of the same name as the file:
#
# Usage: box chunk-sql {sql_file} [--quiet]
#
#   Result ==> Generates /vagrant/sql/{sql_file}.sql/{sql_file}-??.sql.chunk
#
#   --quiet - Omits output

#
# Split file up into chunks of ~25M or smaller
#
CHUNK_SIZE=25600000

#
# Grab the filename, without extension, then add extension
#
sql_filename="$1"

if [ 'sql' != "$(to_lowercase $(file_extension "${sql_filename}"))" ]; then
    #
    # If no .sql extension, add one.
    #
    importfile="${sql_filename}.sql"
fi

#
# Grab the base file name
#
sql_basefile="${sql_filename%%.*}"

#
# Calculate the SQL filepath from  /vagrant/sql/
#
sql_filepath="${WPLIB_BOX_SQL_DIR}/${sql_filename}"

#
# Check to see if we need to modify exists
#
if [ ! -f "${sql_filepath}" ]  ; then
    echo_if_not_quiet "$*", "=No ${sql_filepath} exists..."
    return
fi

#
# Create temp dir and move our SQL file to temp dir
#
temp_sql_file="$(mktemp --tmpdir="$(pwd)" "${sql_filename}.XXXXX.bak")"
rm -f "${temp_sql_file}"
if [ $? -ne 0 ]; then
	echo "box chunk-sql failed."
fi

#
# Create a backup of the file
#
echo_if_not_quiet "$*", "=Backing up to ${temp_sql_file}..."
mv "${sql_filepath}" "${temp_sql_file}"
if [ $? -ne 0 ]; then
	echo "box chunk-sql failed."
fi

#
# Making a directory the same name as the previous SQL file
#
echo_if_not_quiet "$*", "=Making directory ${sql_filepath}/..."
mkdir -p "${sql_filepath}"
if [ $? -ne 0 ]; then
	echo "box chunk-sql failed."
fi

#
# Making a directory the same name as the previous SQL file
#
echo_if_not_quiet "$*", "=Splitting file into chunks in ${sql_filepath}/..."
split --line-bytes="${CHUNK_SIZE}" --numeric-suffixes="1" --additional-suffix=".sql.chunk" "${temp_sql_file}" "${sql_filename}/${sql_basefile}-"
if [ $? -eq 0 ]; then
    echo_if_not_quiet "$*", "=SQL file chunked."
else
	echo "box chunk-sql failed."
    rm -rf "${temp_sql_dir}"
    mv "${sql_filepath}.bak" "${sql_filepath}"
fi






