#!/bin/bash
#
# Script for handling database related functionality.
#
# Usage: box database {sub-command} [{command-options}] [--dryrun] [--quiet]
#

DEFAULT_PROJECT="wplib"
DB_HOST_IP="172.18.0.1"
source "${WPLIB_BOX_COLORS_FILE}"

trap ctrl_c INT

function ctrl_c()
{
    tput sgr0
	echo ""
	echo "$ECHO_PREFIX Aborting script"
	exit
}

#
# Unchunk a SQL file that has been chunked
#
# Usage: box database import [{dump_file}] [{global-options}]
#
#   Result ==> Imports from /vagrant/sql/{dump_file}.sql
#
function database_unchunk() {
    local chunked_file="$1"
    local basefile="${chunked_file%%.*}"
    local ext="${chunked_file##*.}"

    if [ 'sql' != "$(to_lowercase "${ext}")" ]; then
        #
        # If no .sql extension, add one.
        #
        ext="sql"
    fi

    #
    # Force import from  /vagrant/sql/
    #
    chunked_file="${WPLIB_BOX_SQL_DIR}/${basefile}.${ext}"

    #
    # Check to see if we the chunked_file exists
    #
    if [ ! -e "${chunked_file}" ]; then
        alert "No ${chunked_file} exists"
        return 1
    fi

    if [ ! -d "${chunked_file}" ]; then
        alert "${chunked_file} is not a directory"
        return 2
    fi

    temp_dir="$(mktemp "${WPLIB_BOX_SQL_DIR}/${basefile}-XXXXX.${ext}")"
    if [ $? -ne 0 ]; then
        output "Cannot create temp directory ${temp_dir}"
        return 3
    fi

    rm "${temp_dir}"
    if [ $? -ne 0 ]; then
        output "Cannot remove temp directory ${temp_dir}"
    fi

    mv "${chunked_file}" "${temp_dir}"
    if [ $? -ne 0 ]; then
        output "Cannot rename ${chunked_file} directory ${temp_dir}"
        return 4
    fi

    cat "${temp_dir}/${basefile}"-??."${ext}.chunk" > $chunked_file
    if [ $? -ne 0 ]; then
        output "Could not generate unchunked file ${chunked_file}"
        return 5
    fi

    rm -rf "${temp_dir}"
    if [ $? -ne 0 ]; then
        output "Could not remove the chunked directory ${temp_dir}"
    fi

    output "SQL file ${chunked_file} unchunked"

}

#
# Import a database from /vagrant/sql/$1.sql
#
# Usage: box database import [{dump_file}] [{global-options}]
#
#   Result ==> Imports from /vagrant/sql/{dump_file}.sql
#
function database_import() {

    local importfile="$1"

    local ext="$(file_extension "${importfile}")"

    if [ 'sql' != "$(to_lowercase "${ext}")" ]; then
        #
        # If no .sql extension, add one.
        #
        ext="sql"
        importfile="${importfile}.${ext}"
    fi

    #
    # Force import from  /vagrant/sql/
    #
    importfile="${WPLIB_BOX_SQL_DIR}/${importfile}"

    #
    # Check to see if we the importfile exists
    #
    if [ ! -e "${importfile}" ]; then

        output "No ${importfile} exists"
        return 1

    fi

    basefile="${importfile%%.*}"

    if [ ! -d "${importfile}" ]; then
        tempfile=""
    else

        tempfile="$(mktemp "${WPLIB_BOX_SQL_DIR}/${basefile}-XXXXX.${ext}")"
        if [ $? -ne 0 ]; then
            output "Cannot create temp file ${tempfile}"
            return 2
        fi

        output "Unchunking ${importfile}"
        cat "${importfile}/${basefile}"-??."${ext}.chunk" > $tempfile
        if [ $? -ne 0 ]; then
            output "Could not generate unchunked file ${chunked_file}"
            return 3
        fi

        importfile="${tempfile}"

    fi

    output "Backing up database"

    database_backup "${basefile}.bak"

    if [ $? -ne 0 ]; then
        output "Error when backing up to ${basefile}.bak"
        return 4
    fi

    output "Database backed-up to ${bakfile}"

    output "Dropping any prior tables"

    if [ ! $(has_arg --dryrun) ]; then
        #
        # @TODO: Switch this to using Docker
        #
        mysql -u wordpress -pwordpress -Nse "show tables;" wordpress 2>&1 | grep -v "Warning:" > /tmp/mysql-table-list.txt
        cat /tmp/mysql-table-list.txt | while read table; do mysql -u wordpress -pwordpress -e "drop table $table" wordpress 2>&1 | grep -v "Warning:"; done
        rm /tmp/mysql-table-list.txt
    fi
    output "Tables dropped"

    if [ "" != "$(cat "${importfile}" | grep "utf8mb4_unicode_520_ci")" ]; then
        #
        # MariaDB does not support 'utf8mb4_unicode_520_ci' but does support 'utf8mb4_unicode_ci'
        # This should become a lot more intelligent but for now it should suffice.
        #
        output "Stripping '520' from 'utf8mb4_unicode_520_ci' in ${importfile}"
        if [ ! $(has_arg --dryrun) ]; then
            sed -i -e 's/utf8mb4_unicode_520_ci/utf8mb4_unicode_ci/g' "${importfile}"
        fi
        output "520 stripped"
    fi

    output "Importing database from ${importfile}"
    #
    # @TODO: Switch this to using Docker
    #
    if [ ! $(has_arg --dryrun) ]; then
        mysql -u wordpress -pwordpress wordpress < ${importfile}  2>&1 | grep -v "Warning:"
    fi

    if [ "" != "${tempfile}" ]; then
        rm "${tempfile}"
    fi

    output "Database imported"

}

#
# Converts a SQL file into a collection of `.sql.chunk` files
# in a directory of the same name as the file:
#
# Usage: box database chunk {sql_file} [{global-options}]
#
#   Result ==> Generates /vagrant/sql/{sql_file}.sql/{sql_file}-??.sql.chunk
#
#   --quiet - Omits output
function database_chunk() {

    #
    # Split file up into chunks of 25Mb or smaller
    #
    CHUNK_SIZE=25M

    #
    # Grab the filename, without extension, then add extension
    #
    sql_filename="$1"

    #
    # Check to see if arg was passed
    #
    if [ "" == "${sql_filename}" ]; then
        alert "No <sql_file> passed"
        return 1
    fi

    #
    # Grab the base file name
    #
    sql_basename="${sql_filename%%.*}"

    #
    # Fix the filename
    #
    sql_filename="${sql_basename}.sql"

    #
    # Calculate the SQL filepath from  /vagrant/sql/
    #
    sql_filepath="${WPLIB_BOX_SQL_DIR}/${sql_filename}"

    #
    # Check to see if we need to modify exists
    #
    if [ ! -f "${sql_filepath}" ]  ; then
        alert "No ${sql_filepath} exists"
        return 2
    fi

    #
    # Create temp dir and move our SQL file to temp dir
    #
    backup_file="$(mktemp "${WPLIB_BOX_SQL_DIR}/${sql_basename}.XXXXX.sql.bak")"
    rm -f "${backup_file}"
    if [ $? -ne 0 ]; then
        alert "Could not make backup sql file ${backup_file}"
        return 3
    fi

    #
    # Backing up of the file
    #
    mv "${sql_filepath}" "${backup_file}"
    if [ $? -ne 0 ]; then
        alert "Could not backup ${sql_filepath}"
        return 4
    fi

    #
    # Making a directory the same name as the previous SQL file
    #
    mkdir -p "${sql_filepath}"
    if [ $? -ne 0 ]; then
        alert "Could not create directory ${sql_filepath}/"
        return 5
    fi

    #
    # Making a directory the same name as the previous SQL file
    #
    split \
        --line-bytes="${CHUNK_SIZE}" \
        --numeric-suffixes="1" \
        --additional-suffix=".sql.chunk" \
        "${backup_file}" \
        "${sql_filename}/${sql_basename}-"
    if [ $? -ne 0 ]; then
        alert "Could not chunk ${backup_file} into ${sql_filepath}"
        rm -rf "${sql_filepath}"
        mv "${backup_file}" "${sql_filepath}"
        return 6
    fi

    chunk_list_file="$(mktemp --tmpdir=/tmp chunk-list-XXXX.txt)"
    if [ $? -ne 0 ]; then
        alert "Could not generate chunk list filename"
        return 8
    fi

    ls -1 "${sql_filename}/"*.chunk > $chunk_list_file
    if [ $? -ne 0 ]; then
        alert "Could not generate chunk list file"
        return 9
    fi

    chunk_count="$(cat "${chunk_list_file}" | wc -l)"
    if [ $? -ne 0 ]; then
        alert "Could not count chunks generated into ${sql_filepath}/"
        return 10
    fi

    saveIFS="${IFS}" && IFS=$'\n'
    chunk_list="$(cat "${chunk_list_file}")"
    rm "${chunk_list_file}"
    for file in $chunk_list
    do
        echo -e "\t\t\"$(md5sum $file|cut -d " " -f1)\"," >> $chunk_list_file
        if [ $? -ne 0 ]; then
            alert "Could not generate checksum of ${file}"
            return 11
        fi
    done
    IFS="${saveIFS}"
    checksums="$(cat "${chunk_list_file}")"

    cat << JSON > ${sql_filepath}/$sql_basename.chunks.json
{
        "schema": "1.0",
        "chunk_count": "${chunk_count}",
        "max_chunk_size": "${CHUNK_SIZE}",
        "checksums": [
${checksums: : -1}
        ]
}
JSON

    if [ $? -ne 0 ]; then
        alert "Could not generate ${sql_filepath}/{$sql_basename}.chunks.json"
        return 12
    fi

    rm "${chunk_list_file}"
    if [ $? -ne 0 ]; then
        alert "Could not delete the chunk list file ${chunk_list_file}"
    fi

    cat << EOF > $sql_filepath/$sql_basename.README.fcps
File Chunk Packaging Scheme (FCPS)
----------------------------------
This directory should contain ${chunk_count} chunks of the original file ${sql_filename}.
If was generated with the 'box database chunk "${sql_filename}"' command from the CLI[1]
for WPLib Box[2].

You can reconstitute the orginal file ${sql_filename} if the chuncks are located in
/vagrant/sql/ as /vagrant/sql/${sql_filename}/ and the files have not been modified
since they were generated using the 'box database unchunk "${sql_filename}"' command
when inside of WPLib Box which you can acccess from your host computer using the
bash or batch/Powershell command 'vagrant ssh'.

In the case you do not have WPLib Box and cannot install it you can reconstitute the
original SQL file in Bash (e.g. Mac and Linux) using this command when run from the
directory with contains the XXX subdirectory containing the chunks:

    mv "${sql_filename}/" "${sql_filename}.tmp/"
    cat "${sql_filename}/${sql_basename}"-??."${ext}.chunk" > $sql_filename

On Windows this is what (WE THINK) you will need to do, though we have not tested it
yet (contact us here https://github.com/wplib/box-scripts/issues if these commands
do not work for you, please):

    ren "${sql_filename}/" "${sql_filename}.tmp/"
    copy "${sql_filename}/${sql_basename}-*.${ext}.chunk" ../$sql_filename

FCPS is licensed via GPLv3: https://www.gnu.org/licenses/gpl-3.0.en.html
Copyright (C) 2018 NewClarity Consulting LLC; All rights reserved worldwide

[1] https://github.com/wplib/box-scripts
[2] https://github.com/wplib/wplib-box
EOF

    if [ $? -ne 0 ]; then
        alert "Could not generate ${sql_filepath}/{$sql_basename}.README.fcps"
        return 13
    fi

    rm "${backup_file}"
    if [ $? -ne 0 ]; then
        alert "Could not delete the backup file ${backup_file}"
    fi

    output "SQL file ${sql_filepath} chunked"

}

#
# Backup the database to /vagrant/sql/backup.sql
#
# Usage: box database backup [{backup_file}] [{global-options}]
#
#   Result ==> Backs up to /vagrant/sql/{backup_file}.sql
#
#   --quiet - Omits status messages
#   --dryrun - Do everything except actually run it
#
#   Rolls forward existing files per shift_files() logic.
#
function database_backup() {

    bakfile="${WPLIB_BOX_SQL_DIR}/backup.sql"

    #
    # Check to see if we need to save a prior backup
    #
    if [[ -f "${bakfile}" || -d "${bakfile}" ]]  ; then

        output "Saving prior backups"

        #
        # Shift the files forward backup.sql becomes backup1.sql, etc. 
        #
        shift_files "${bakfile}"

    fi

    output "Backing up database to ${bakfile}"

    if [ ! $(has_arg --dryrun) ]; then

        mkdir -p "${WPLIB_BOX_SQL_DIR}/"

        docker run --rm -it -e MYSQL_ALLOW_EMPTY_PASSWORD=yes -e MYSQL_DATABASE=wordpress -e MYSQL_USER=wordpress -e MYSQL_PASSWORD=wordpress -v /tmp/sql:/docker-entrypoint-initdb.d -v mysql_data:/var/lib/mysql wplib/mysql:5.5.59 mysqldump -h "${DB_HOST_IP}"  -u wordpress  -pwordpress wordpress 2>&1  | grep -v "Warning: Using a password on the command line interface can be insecure." > ${bakfile}            
        result="$?"

        if [ "${result}" != "0" ]; then

            output "mysqldump error (${result})"
            return 1

        fi

    fi

    output "Database backed up"

}

function database_help() {
	cat <<EOF
box database [32mbackup(B[m [<sql_file>] - Backup current database to <sql_file> or backup.sql.
box database [32mimport(B[m [<sql_file>] - Import <sql_file> or provision.sql into current database.
box database [32mchunk(B[m <sql_file>    - Split <sql_file> into chunks ~25Mb in size.
box database [32munchunk(B[m <sql_file>  - Unsplit <sql_file> back into a complete file.

box database [32mcredentials(B[m         - This will output host, username and password
box database [32mdbname(B[m              - This will output database name
box database [32musername(B[m            - This will output database login username
box database [32mpassword(B[m            - This will output database login password
EOF

}

################################################################################
#if [ "$1" == "database" ]
#then
#	# We are running from the box script, instead of directly.
#fi
CMD="$1"
shift
IMAGES="$@"

case $CMD in
    'help')
        database_help
        ;;

    'dbname'|'name'|'username'|'user'|'password'|'pw')
        echo wordpress
		;;

    'host'|'hostname'|'server'|'hostip'|'host-ip')
        echo "${DB_HOST_IP}"
		;;

    'credentials'|'creds'|'login')
        echo "Host:     ${GREEN}${DB_HOST_IP}${RESET}"
        echo "Database: ${GREEN}wordpress${RESET}"
        echo "Username: ${GREEN}wordpress${RESET}"
        echo "Password: ${GREEN}wordpress${RESET}"
		;;

    'backup'|'dump'|'save')
        database_backup "$1"
		;;

    'import'|'restore'|'undump')
        database_import "$1"
		;;

    'chunk'|'split')
        database_chunk "$1"
		;;

    'unchunk'|'join')
        database_unchunk "$1"
		;;

	*)
		if [ "$1" == "" ]
		then
			echo "$ECHO_PREFIX ${RED}Error: No database command provided.${RESET}"
			database_help
			exit 1
		fi
		;;
esac

